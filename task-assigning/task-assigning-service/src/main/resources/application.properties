#
# Copyright 2021 Red Hat, Inc. and/or its affiliates.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

%dev.quarkus.swagger-ui.always-include=true

quarkus.optaplanner.solver-config-xml=taskAssigningDefaultSolverConfig.xml

# This property is only defined for the kafka health check BUT for the kafka clients that the application will use
# to connect to the servers the following property must be used instead .
# Ins
# see https://github.com/quarkusio/quarkus/issues/7609
#quarkus.kafka-streams.bootstrap-servers=localhost:909255

# This is the real property name to use!!!!.
# When set, will override the kafka by default value = localhost:9092. If not set, then the kafka by default
# value is being used instead.
# I'm configuring this intentionally to not forget the "trick" since quarkus documentation looks to not be clear here.
kafka.bootstrap.servers=localhost:9092



quarkus.optaplanner.solver.domain-access-type=REFLECTION

#quarkus.optaplanner.solver-config-xml=ABC.xml

#//quarkus.optaplanner.solver.termination.spent-limit=2s


#%dev.quarkus.optaplanner.solver.termination.spent-limit=2s


quarkus.log.category."org.kie.kogito.taskassigning".min-level=DEBUG
quarkus.log.category."org.kie.kogito.taskassigning".level=DEBUG


# task assigning properties

kogito.task-assigning.data-index.server-url=http://localhost:8180/graphql

kogito.task-assigning.data-index.client.auth.basic.user=basic user

kogito.task-assigning.data-index.client.auth.basic.password=basic password

#kogito.task-assigning.data-index.client.auth.keycloak.auth-server-url=http://localhost:8280/auth

#kogito.task-assigning.data-index.client.auth.keycloak.realm=kogito

#kogito.task-assigning.data-index.client.auth.keycloak.client-id=keycloack client id
#
#kogito.task-assigning.data-index.client.auth.keycloak.credentials.secret=keycloak secret
#
#kogito.task-assigning.data-index.client.auth.keycloak.user=keycloak user
#
#kogito.task-assigning.data-index.client.auth.keycloak.password=keycloack password

org.kie.kogito.taskassigning.resource.CheckConcurrencyClient/mp-rest/url=http://localhost:8280
org.kie.kogito.taskassigning.resource.CheckConcurrencyClient/mp-rest/mp-rest/scope=javax.inject.Singleton


#The maximum delay between invocations of poll() when using consumer group management.
#This places an upper bound on the amount of time that the consumer can be idle before fetching more records.
#If poll() is not called before expiration of this timeout, then the consumer is considered failed and the group will
#rebalance in order to reassign the partitions to another member. For consumers using a non-null group.instance.id which
#reach this timeout, partitions will not be immediately reassigned. Instead, the consumer will stop sending heartbeats
#and partitions will be reassigned after expiration of session.timeout.ms. This mirrors the behavior of a static consumer
#which has shutdown.
#Defaut 5 minutes

# Kafka default value is 300000 (5 minutes)
mp.messaging.incoming.kogito-usertaskinstances-events.max.poll.interval.ms=300000

# Kafka default value is 500 (max records to pick up in a poll() from the broker)
mp.messaging.incoming.kogito-usertaskinstances-events.max.poll.records=40

# SmallRye configuration parameter, default value is 60000 (1 minute)
# Determines the max time a read record from the topic can be without being acked or nacked before SmallRye considers
# that there has been an error.
# Each SmallRye received record as it's own receive time, and thus the check is done for each of the picked records.
# This value must be greater than the kogito.task-assigning.buffered-user-task-event-consumer.deferred-handle-timout.ms
# since this is the amount of time we delay the event processing when the BackpressureBufferedEventConsumer has paused
# the events delivery to the consumer.
#mp.messaging.incoming.kogito-usertaskinstances-events.throttled.unprocessed-record-max-age.ms=

# period of time the BackpressureBufferedEventConsumer will wait before picking a message and storing into the buffer
# when it's paused. This value is related with the max.poll.interval and the max.pol.records, should be configured
# in a way that  max.poll.interval.ms < (max.poll.records * deferred-handle-timout.ms)
kogito.task-assigning.buffered-user-task-event-consumer.deferred-handle-timout.ms=5000
